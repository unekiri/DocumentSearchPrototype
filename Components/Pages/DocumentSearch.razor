@page "/document-search"
@rendermode InteractiveServer

@using System.Text
@using System.Text.Json
@using System.Text.Json.Serialization
@using Azure.Storage.Blobs
@using Azure.Storage.Blobs.Models
@using Azure.Storage.Sas

@inject IHttpClientFactory HttpClientFactory
@inject IConfiguration Configuration
@inject IJSRuntime JSRuntime
@inject BlobServiceClient BlobServiceClient
@inject ILogger<DocumentSearch> Logger

<PageTitle>金入設計書の検索</PageTitle>

<h1>金入設計書の検索</h1>

<p>検索ワードを入力してください。</p>

<div class="input-group mb-3">
    <input type="text" class="form-control" @bind="searchTerm" @onkeyup="HandleKeyUp"/>
    <button class="btn btn-primary" @onclick="Search" disabled="@isLoading">
        @if (isLoading)
        {
            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
            <span>Searching...</span>
        }
        else
        {
            <span class="bi bi-search"></span>
            <span>Search</span>
        }
    </button>
</div>

<div class="card mb-3">
    <div class="card-header">
        <button class="btn btn-link text-decoration-none w-100 text-start" @onclick="ToggleFilter">
            <i class="bi @(showFilter ? "bi-chevron-up" : "bi-chevron-down")"></i>
            フィルター
        </button>
    </div>
    @if (showFilter)
    {
        <div class="card-body">
            <div class="row">
                <div class="col-md-3 mb-3">
                    <label class="form-label">都道府県</label>
                    <select @bind="filterPrefecture" @bind:after="OnFilterChanged" class="form-select">
                        <option value="">全て</option>
                        @foreach (var p in availablePrefectures)
                        {
                            <option value="@p">@p</option>
                        }
                    </select>
                </div>
                <div class="col-md-3 mb-3">
                    <label class="form-label">市区町村</label>
                    <select @bind="filterMunicipality" @bind:after="OnFilterChanged" class="form-select">
                        <option value="">全て</option>
                        @foreach (var m in availableMunicipalities)
                        {
                            <option value="@m">@m</option>
                        }
                    </select>
                </div>
                <div class="col-md-3 mb-3">
                    <label class="form-label">年度</label>
                    <select @bind="filterYear" @bind:after="OnFilterChanged" class="form-select">
                        <option value="">全て</option>
                        @foreach (var y in availableYears)
                        {
                            <option value="@y">@y</option>
                        }
                    </select>
                </div>
                <div class="col-md-3 mb-3">
                    <label class="form-label">工事分類</label>
                    <select @bind="filterConstructionType" @bind:after="OnFilterChanged" class="form-select">
                        <option value="">全て</option>
                        @foreach (var ct in availableConstructionTypes)
                        {
                            <option value="@ct">@ct</option>
                        }
                    </select>
                </div>
            </div>
            <button class="btn btn-secondary btn-sm" @onclick="ClearFilters">フィルターをクリア</button>
        </div>
    }
</div>

@if (searchResults != null && searchResults.Any())
{
    <h4>検索結果</h4>
    <div class="list-group">
        @foreach (var result in searchResults)
        {
            <div class="list-group-item list-group-item-action" @onclick="() => ViewDocument(result.FileName)" style="cursor: pointer;" title="Click to view document">
                <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">@result.FileName</h5>
                </div>
                <p class="mb-1">
                    最も関連性の高いページ <strong>@result.TopPageNumber</strong>.
                </p>
            </div>
        }
    </div>
}
else if (isLoading)
{
    <p><em>Searching...</em></p>
}
else if (searchAttempted && (searchResults == null || !searchResults.Any()))
{
    <div class="alert alert-warning" role="alert">
        No results found for "@searchedTerm".
    </div>
}


@code {
    private string? searchTerm;
    private string? searchedTerm;
    private bool isLoading = false;
    private bool searchAttempted = false;
    private List<SearchResult>? searchResults;
    private List<SearchResult>? allSearchResults;

    // フィルター関連
    private bool showFilter = false;
    private string filterPrefecture = "";
    private string filterMunicipality = "";
    private string filterYear = "";
    private string filterConstructionType = "";

    private List<string> availablePrefectures = new();
    private List<string> availableMunicipalities = new();
    private List<string> availableYears = new();
    private List<string> availableConstructionTypes = new();
    private Dictionary<string, BlobMetadata> blobMetadataCache = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadAvailableFilters();
    }

    private async Task LoadAvailableFilters()
    {
        try
        {
            var containerName = Configuration["AzureStorage:ContainerName"];
            if (string.IsNullOrEmpty(containerName))
            {
                return;
            }

            var containerClient = BlobServiceClient.GetBlobContainerClient(containerName);

            var prefectures = new HashSet<string>();
            var municipalities = new HashSet<string>();
            var years = new HashSet<string>();
            var constructionTypes = new HashSet<string>();

            await foreach (var blobItem in containerClient.GetBlobsAsync(BlobTraits.Metadata))
            {
                var metadata = new BlobMetadata();

                if (blobItem.Metadata.TryGetValue("Prefecture", out var prefecture))
                {
                    prefectures.Add(prefecture);
                    metadata.Prefecture = prefecture;
                }

                if (blobItem.Metadata.TryGetValue("Municipality", out var municipality))
                {
                    municipalities.Add(municipality);
                    metadata.Municipality = municipality;
                }

                if (blobItem.Metadata.TryGetValue("FiscalYear", out var year))
                {
                    years.Add(year);
                    metadata.Year = year;
                }

                if (blobItem.Metadata.TryGetValue("ConstructionType", out var constructionType))
                {
                    constructionTypes.Add(constructionType);
                    metadata.ConstructionType = constructionType;
                }

                blobMetadataCache[blobItem.Name] = metadata;
            }

            availablePrefectures = prefectures.OrderBy(x => x).ToList();
            availableMunicipalities = municipalities.OrderBy(x => x).ToList();
            availableYears = years.OrderByDescending(x => x).ToList();
            availableConstructionTypes = constructionTypes.OrderBy(x => x).ToList();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load available filters");
        }
    }

    private void ToggleFilter()
    {
        showFilter = !showFilter;
    }

    private void OnFilterChanged()
    {
        ApplyFilters();
    }

    private void ApplyFilters()
    {
        if (allSearchResults == null || !allSearchResults.Any())
        {
            return;
        }

        var filtered = allSearchResults.Where(r =>
        {
            if (!blobMetadataCache.TryGetValue(r.FileName, out var metadata))
            {
                return false;
            }

            if (!string.IsNullOrWhiteSpace(filterPrefecture) && metadata.Prefecture != filterPrefecture)
            {
                return false;
            }

            if (!string.IsNullOrWhiteSpace(filterMunicipality) && metadata.Municipality != filterMunicipality)
            {
                return false;
            }

            if (!string.IsNullOrWhiteSpace(filterYear) && metadata.Year != filterYear)
            {
                return false;
            }

            if (!string.IsNullOrWhiteSpace(filterConstructionType) && metadata.ConstructionType != filterConstructionType)
            {
                return false;
            }

            return true;
        }).ToList();

        searchResults = filtered;
    }

    private void ClearFilters()
    {
        filterPrefecture = "";
        filterMunicipality = "";
        filterYear = "";
        filterConstructionType = "";
        searchResults = allSearchResults;
    }

    private async Task ViewDocument(string fileName)
    {
        try
        {
            var containerName = Configuration["AzureStorage:ContainerName"];
            if (string.IsNullOrWhiteSpace(containerName))
            {
                Logger.LogError("AzureStorage:ContainerName is not configured.");
                await JSRuntime.InvokeVoidAsync("alert", "Storage container is not configured.");
                return;
            }

            var containerClient = BlobServiceClient.GetBlobContainerClient(containerName);
            var blobClient = containerClient.GetBlobClient(fileName);

            if (await blobClient.ExistsAsync())
            {
                var sasBuilder = new BlobSasBuilder
                {
                    BlobContainerName = containerName,
                    BlobName = fileName,
                    Resource = "b", // "b" for blob
                    ExpiresOn = DateTimeOffset.UtcNow.AddMinutes(15)
                };

                sasBuilder.SetPermissions(BlobSasPermissions.Read);

                Uri sasUri = blobClient.GenerateSasUri(sasBuilder);
                Logger.LogInformation("Generated SAS URL for blob {BlobName} in container {ContainerName}.", fileName, containerName);
                await JSRuntime.InvokeVoidAsync("open", sasUri.ToString(), "_blank");
            }
            else
            {
                Logger.LogWarning("Blob not found. Container={ContainerName}, BlobName={BlobName}", containerName, fileName);
                await JSRuntime.InvokeVoidAsync("alert", $"File '{fileName}' not found in storage.");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to generate SAS URL. BlobName={BlobName}", fileName);
            await JSRuntime.InvokeVoidAsync("alert", $"Error generating file URL: {ex.Message}");
        }
    }

    private async Task Search()
    {
        if (string.IsNullOrWhiteSpace(searchTerm))
        {
            return;
        }

        isLoading = true;
        searchAttempted = true;
        searchedTerm = searchTerm;
        searchResults = null;
        allSearchResults = null;

        var httpClient = HttpClientFactory.CreateClient("AzureSearchClient");
        Logger.LogInformation("Search requested. TermLength={TermLength}", searchTerm.Length);
        Logger.LogDebug("Search term={SearchTerm}", searchTerm);

        var requestBody = new
        {
            search = searchTerm,
            count = true,
            searchMode = "any"
        };

        var content = new StringContent(JsonSerializer.Serialize(requestBody), Encoding.UTF8, "application/json");

        try
        {
            var indexName = Configuration["AzureSearch:IndexName"];
            if (string.IsNullOrEmpty(indexName))
            {
                Logger.LogError("AzureSearch:IndexName is not configured.");
                throw new InvalidOperationException("Azure Search IndexName is not configured.");
            }

            var requestUrl = $"indexes/{indexName}/docs/search?api-version=2024-05-01-preview";
            var response = await httpClient.PostAsync(requestUrl, content);
            if (!response.IsSuccessStatusCode)
            {
                var errorBody = await response.Content.ReadAsStringAsync();
                var truncated = errorBody.Length > 2048 ? errorBody[..2048] : errorBody;
                Logger.LogWarning(
                    "Azure Search request failed. StatusCode={StatusCode}, Reason={ReasonPhrase}, Url={Url}, Body={Body}",
                    (int)response.StatusCode,
                    response.ReasonPhrase,
                    requestUrl,
                    truncated);
                searchResults = null;
                return;
            }

            var responseBody = await response.Content.ReadFromJsonAsync<SearchApiResponse>();

            allSearchResults = responseBody?.Value?
                .GroupBy(r => r.FileName)
                .Select(g =>
                {
                    var top = g.OrderByDescending(r => r.Score).First();
                    var pages = g.Select(r => r.PageNumber).Distinct().OrderBy(p => p).ToList();
                    return new SearchResult(g.Key, top.PageNumber, top.Score, pages);
                })
                .OrderByDescending(r => r.TopScore)
                .ToList();

            // フィルターを適用
            ApplyFilters();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Search failed. TermLength={TermLength}", searchTerm.Length);
            searchResults = null;
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await Search();
        }
    }

    // C# record types to deserialize the JSON response
    public record SearchResult(string FileName, int TopPageNumber, double TopScore, List<int> PageNumbers);

    public class SearchApiResponse
    {
        [JsonPropertyName("@odata.count")]
        public int? Count { get; set; }

        [JsonPropertyName("value")]
        public List<ApiResultValue>? Value { get; set; }
    }

    public class ApiResultValue
    {
        [JsonPropertyName("@search.score")]
        public double Score { get; set; }

        [JsonPropertyName("metadata_storage_name")]
        public string FileName { get; set; } = string.Empty;

        [JsonPropertyName("pageNumber")]
        public int PageNumber { get; set; }
    }

    public class BlobMetadata
    {
        public string Prefecture { get; set; } = "";
        public string Municipality { get; set; } = "";
        public string Year { get; set; } = "";
        public string ConstructionType { get; set; } = "";
    }
}
